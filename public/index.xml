<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>blog of hqh</title>
    <link>https://hu-qing-hua.github.io/</link>
    <description>Recent content on blog of hqh</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>© hu-qing-hua</copyright>
    <lastBuildDate>Mon, 08 Sep 2025 02:01:58 +0530</lastBuildDate>
    <atom:link href="https://hu-qing-hua.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>About</title>
      <link>https://hu-qing-hua.github.io/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://hu-qing-hua.github.io/about/</guid>
      <description>I am Hu Qinghua.</description>
    </item>
    <item>
      <title>go-zero源码阅读笔记</title>
      <link>https://hu-qing-hua.github.io/posts/post-9/</link>
      <pubDate>Mon, 08 Sep 2025 02:01:58 +0530</pubDate>
      <guid>https://hu-qing-hua.github.io/posts/post-9/</guid>
      <description>/core/mr 实现了一个并行的接口&#xA;func MapReduce： 我之前阅读 MapReduce 论文并实现了一个统计字符串的具体任务，mr包里的实现的更通用，思想是一样的。 保证安全性:&#xA;MapReduce里的参数：panicChan := &amp;amp;onceChan{channel: make(chan any)},在执行全过程里都会监听这个管道的写入情况，出错就把错误信息写进去，并且通过atomic管理一个变量保证管道只写入一次 Option参数可以设置当前函数的context,全程监听context Done()是否执行 Q&amp;amp;A: 1.因为generate执行的协程里数据全写到source chan后就会close(source), 但是在excutemapper里有一个协程池pool := make(chan struct{}, mCtx.workers) 有空的缓冲区的时候会一直尝试读取source里的函数进行工作。 Q:万一source里的数据没读完就被close了怎么办 A:关闭channel不会清空数据，可以一直读，空了item, ok := &amp;lt;-mCtx.source才会返回失败 其他函数 mr里的别的函数：例如finish(fns &amp;hellip;func() error)error，本质上是把一个包装好的MapReduce的调用： 1.func1、func2&amp;hellip;这些函数当作数据写入generate里的source， 2.写好mapper函数内容：执行“数据”，报错就调用cancel() 3.reduce函数写空&#xA;实现细节上学习到的: go里的闭包捕获是自动的，不需要写明，而且是引用捕获 看到go里的泛型，和c++模板元编程相比，泛型做不到编译时计算 type onceChan struct { channel chan any wrote int32 } func (oc *onceChan) write(val any) { if atomic.CompareAndSwapInt32(&amp;amp;oc.wrote, 0, 1) { oc.channel &amp;lt;- val } } 实现只写入一次的管道； func CompareAndSwapInt32(addr *int32, old, new int32) bool 原子操作完成比较 *addr是否等于old，一致就更新 *addr=new,返回true;不一致就返回false</description>
    </item>
    <item>
      <title>用go实现Redis的功能</title>
      <link>https://hu-qing-hua.github.io/posts/post-8/</link>
      <pubDate>Fri, 08 Aug 2025 02:01:58 +0530</pubDate>
      <guid>https://hu-qing-hua.github.io/posts/post-8/</guid>
      <description>实现思路 </description>
    </item>
    <item>
      <title>MIT-6.824-2025Spring-Lab1/2/3踩坑记录</title>
      <link>https://hu-qing-hua.github.io/posts/post-7/</link>
      <pubDate>Sun, 08 Jun 2025 02:01:58 +0530</pubDate>
      <guid>https://hu-qing-hua.github.io/posts/post-7/</guid>
      <description>做lab之前 1.速成golang的基本语法 一个data race的经典例子 func main() { start := time.Now() var t *time.Timer t = time.AfterFunc(randomDuration(), func() { fmt.Println(time.Now().Sub(start)) t.Reset(randomDuration()) }) time.Sleep(5 * time.Second) } func randomDuration() time.Duration { return time.Duration(rand.Int63n(1e9)) } 先看afterfunc的介绍 “AfterFunc waits for the duration to elapse and then calls f in its own goroutine. It returns a Timer that can be used to cancel the call using its Stop method. The returned Timer&amp;rsquo;s C field is not used and will be nil.</description>
    </item>
    <item>
      <title>记录一直忽略的工具之类</title>
      <link>https://hu-qing-hua.github.io/posts/post-2/</link>
      <pubDate>Thu, 17 Apr 2025 02:01:58 +0530</pubDate>
      <guid>https://hu-qing-hua.github.io/posts/post-2/</guid>
      <description>第一章 terminal是负责处理输入输出的窗口，也负责处理窗口显示的字体颜色等。 (starship,terminal)类似于(网页的js,浏览器引擎)（starship使用标准的ECMA-48控制序列（所有现代终端都支持），就像所有网页都可以在一个浏览器上跑一样&#xA;shell 负责调用各种命令(eg:echo\cat&amp;hellip;&amp;hellip;),但输入重定向和输出重定向之类的是shell负责实现的 命令是由系统能力集里来的，就像下图我们寻找它的程序路径 举例子 第二章 2.work2:&#xA;#! /usr/bin/fish function marco pwd &amp;gt; /tmp/missing/record.txt echo save the path done end function polo if test -f /tmp/missing/record.txt if cd (cat /tmp/missing/record.txt) echo cd successed else echo cd failed end else echo can not find record.txt. end end 3.work3: 循环调用找bug的脚本&#xA;#!/usr/bin/fish set n 0 while true ./base.sh &amp;gt;&amp;gt; ./stdout.txt 2&amp;gt;&amp;gt; ./stderr.txt if test $status -ne 0 set n (math $n + 1) echo stdout cat stdout.</description>
    </item>
    <item>
      <title>记录最近接触到的线程池和内存池的原理</title>
      <link>https://hu-qing-hua.github.io/posts/post-1/</link>
      <pubDate>Wed, 09 Apr 2025 02:01:58 +0530</pubDate>
      <guid>https://hu-qing-hua.github.io/posts/post-1/</guid>
      <description>线程池 经常搭配std::future使用，可以处理异步的返回值和异常 内存池 内存池主要思想是提前预分配好一块大内存，由用户管理这块内存的分配和释放，减少频繁调用malloc/free，减少内存碎片</description>
    </item>
  </channel>
</rss>
